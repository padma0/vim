
" ==================== Defaults ================================
" Visual shifting (does not exit Visual mode)
vnoremap < <gv
vnoremap > >gv
" For when you forget to sudo.. Really Write the file.
cmap w!! w !sudo tee % >/dev/null

vnoremap K :m '<-2<CR>gv=gv
vnoremap J :m '>+1<CR>gv=gv

" paste without overwriting last yank
vnoremap P "_dp
vnoremap p "_dP

" cd current directory
nnoremap <leader>cd :cd %:p:h<CR>

" search for visually selected text
vnoremap // "ay/<C-R>a<CR>
" Yank from the cursor to the end of the line
nnoremap Y y$

" ==================== Buffers ================================
noremap <S-l> :bn<CR>
noremap <S-h> :bp<CR>
" set :bd to :bw if you want to totally destroy current buffer
nmap <leader>d :bd<CR>
nmap <leader>D :bufdo bd<CR>

" ==================== Git ================================
" Find merge conflict markers
map <leader>fc /\v^[<\|=>]{7}( .*\|$)<CR>

" ==================== Ultisnips ============================
" let g:UltiSnipsExpandTrigger="<c-j>"
" let g:UltiSnipsJumpForwardTrigger="<c-j>"
" let g:UltiSnipsJumpBackwardTrigger="<c-z>"
" let g:UltiSnipsEditSplit="vertical"

" ==================== crtlp ===================
let g:ctrlp_working_path_mode = 'ra'

if executable('rg')
  set grepprg=rg\ --color=never
  let s:ctrlp_fallback = 'rg %s --files --color=never --glob ""'
  let g:ctrlp_use_caching = 0
elseif executable('ag')
  set grepprg=ag\ --nogroup\ --nocolor
  let s:ctrlp_fallback = 'ag %s -l --nocolor -g ""'
  let g:ctrlp_use_caching = 0
else
  let s:ctrlp_fallback = 'find %s -type f'
endif

let g:ctrlp_custom_ignore = {
      \ 'dir':  '\.git$\|\.hg$\|\.svn$',
      \ 'file': '\.exe$\|\.so$\|\.dll$\|\.pyc$' }
if exists("g:ctrlp_user_command")
  unlet g:ctrlp_user_command
endif

let g:ctrlp_user_command = {
      \ 'types': {
      \ 1: ['.git', 'cd %s && git ls-files . --cached --exclude-standard --others'],
      \ 2: ['.hg', 'hg --cwd %s locate -I .'],
      \ },
      \ 'fallback': s:ctrlp_fallback
      \ }

nnoremap <space>p :CtrlP<CR>
nnoremap <space>r :CtrlPMRU<CR>
nnoremap <space>b :CtrlPBuffer<CR>

" ==================== nerdtree ===================
map <C-e> <plug>NERDTreeTabsToggle<CR>
map <leader>e :NERDTreeFind<CR>

let NERDTreeShowBookmarks=1
let NERDTreeIgnore=['\.py[cd]$', '\~$', '\.swo$', '\.swp$', '^\.git$', '^\.hg$', '^\.svn$', '\.bzr$']
let NERDTreeChDirMode=0
let NERDTreeQuitOnOpen=1
let NERDTreeMouseMode=2
let NERDTreeShowHidden=1
let NERDTreeKeepTreeInNewTab=1
let g:nerdtree_tabs_open_on_gui_startup=0

" ==================== sneak.vim ===================
map f <Plug>Sneak_s
map F <Plug>Sneak_S

" ==================== ctrlsf.vim ===================
let g:ctrlsf_ackprg = 'rg'
nmap <C-a> <Plug>CtrlSFPrompt
vmap <C-a> <Plug>CtrlSFVwordExec
nnoremap <C-j> :CtrlSFOpen<CR>

" ==================== vim-fugitive ===================
" set diff views vertical
set diffopt+=vertical

" ==================== gitv ===================
nnoremap <silent> <leader>gV :Gitv --all<CR>
nnoremap <silent> <leader>gv :Gitv! --all<CR>

" ==================== neocomplete ===================
let g:acp_enableAtStartup = 0
let g:neocomplete#enable_at_startup = 1
let g:neocomplete#enable_smart_case = 1
let g:neocomplete#enable_auto_delimiter = 1
let g:neocomplete#max_list = 15
let g:neocomplete#force_overwrite_completefunc = 1

" Define dictionary.
let g:neocomplete#sources#dictionary#dictionaries = {
      \ 'default' : '',
      \ 'vimshell' : $HOME.'/.vimshell_hist',
      \ 'scheme' : $HOME.'/.gosh_completions'
      \ }

" Define keyword.
if !exists('g:neocomplete#keyword_patterns')
  let g:neocomplete#keyword_patterns = {}
endif
let g:neocomplete#keyword_patterns['default'] = '\h\w*'

" Plugin key-mappings {
" These two lines conflict with the default digraph mapping of <C-K>
if !exists('g:no_neosnippet_expand')
  imap <C-k> <Plug>(neosnippet_expand_or_jump)
  smap <C-k> <Plug>(neosnippet_expand_or_jump)
endif

" This makes the completion popup strictly passive.
" Keypresses acts normally. <ESC> takes you of insert mode, words don't
" automatically complete, pressing <CR> inserts a newline, etc. Iff the
" menu is open, tab will cycle through it. If a snippet is selected, <C-k>
" expands it and jumps between fields.
"   let g:noninvasive_completion = 1
if exists('g:noninvasive_completion')
  inoremap <CR> <CR>
  " <ESC> takes you out of insert mode
  inoremap <expr> <Esc>   pumvisible() ? "\<C-y>\<Esc>" : "\<Esc>"
  " <CR> accepts first, then sends the <CR>
  inoremap <expr> <CR>    pumvisible() ? "\<C-y>\<CR>" : "\<CR>"
  " <Down> and <Up> cycle like <Tab> and <S-Tab>
  inoremap <expr> <Down>  pumvisible() ? "\<C-n>" : "\<Down>"
  inoremap <expr> <Up>    pumvisible() ? "\<C-p>" : "\<Up>"
  " Jump up and down the list
  inoremap <expr> <C-d>   pumvisible() ? "\<PageDown>\<C-p>\<C-n>" : "\<C-d>"
  inoremap <expr> <C-u>   pumvisible() ? "\<PageUp>\<C-p>\<C-n>" : "\<C-u>"
else
  " <C-k> Complete Snippet
  " <C-k> Jump to next snippet point
  imap <silent><expr><C-k> neosnippet#expandable() ?
        \ "\<Plug>(neosnippet_expand_or_jump)" : (pumvisible() ?
        \ "\<C-e>" : "\<Plug>(neosnippet_expand_or_jump)")
  smap <TAB> <Right><Plug>(neosnippet_jump_or_expand)

  inoremap <expr><C-g> neocomplete#undo_completion()
  inoremap <expr><C-l> neocomplete#complete_common_string()
  "inoremap <expr><CR> neocomplete#complete_common_string()

  " <CR>: close popup
  " <s-CR>: close popup and save indent.
  inoremap <expr><s-CR> pumvisible() ? neocomplete#smart_close_popup()."\<CR>" : "\<CR>"

  function! CleverCr()
    if pumvisible()
      if neosnippet#expandable()
        let exp = "\<Plug>(neosnippet_expand)"
        return exp . neocomplete#smart_close_popup()
      else
        return neocomplete#smart_close_popup()
      endif
    else
      return "\<CR>"
    endif
  endfunction

  " <CR> close popup and save indent or expand snippet
  imap <expr> <CR> CleverCr()
  " <C-h>, <BS>: close popup and delete backword char.
  inoremap <expr><BS> neocomplete#smart_close_popup()."\<C-h>"
  inoremap <expr><C-y> neocomplete#smart_close_popup()
endif
" <TAB>: completion.
inoremap <expr><TAB> pumvisible() ? "\<C-n>" : "\<TAB>"
inoremap <expr><S-TAB> pumvisible() ? "\<C-p>" : "\<TAB>"

function! CleverTab()
  if pumvisible()
    return "\<C-n>"
  endif
  let substr = strpart(getline('.'), 0, col('.') - 1)
  let substr = matchstr(substr, '[^ \t]*$')
  if strlen(substr) == 0
    " nothing to match on empty string
    return "\<Tab>"
  else
    " existing text matching
    if neosnippet#expandable_or_jumpable()
      return "\<Plug>(neosnippet_expand_or_jump)"
    else
      return neocomplete#start_manual_complete()
    endif
  endif
endfunction

imap <expr> <Tab> CleverTab()

" ==================== neosnippet ===================
" Use honza's snippets.
let g:neosnippet#snippets_directory='~/.vim/bundle/vim-snippets/snippets'

" Enable neosnippet snipmate compatibility mode
let g:neosnippet#enable_snipmate_compatibility = 1

" For snippet_complete marker.
if has('conceal')
  set conceallevel=2 concealcursor=i
endif

" Enable neosnippets when using go
let g:go_snippet_engine = "neosnippet"

" Disable the neosnippet preview candidate window
" When enabled, there can be too much visual noise
" especially when splits are used.
set completeopt-=preview
